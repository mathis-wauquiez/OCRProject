
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post-Clustering Refinement ‚Äî Methodology Report</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f9f9f9;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .header h1 {
            margin: 0 0 10px 0;
        }
        .metadata {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        /* Collapsible Section Styles - FIXED FOR LARGE CONTENT */
        .section {
            background: white;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: visible;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s ease;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .section-header:hover {
            background: linear-gradient(135deg, #7688f0 0%, #8555b2 100%);
        }
        
        .section-title {
            margin: 0;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .section-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .toggle-icon {
            width: 24px;
            height: 24px;
            border: 2px solid white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: transform 0.3s ease;
        }
        
        .section.collapsed .toggle-icon {
            transform: rotate(0deg);
        }
        
        .section.expanded .toggle-icon {
            transform: rotate(90deg);
        }
        
        /* FIXED: Use display instead of max-height for large sections */
        .section-content {
            display: none;
            padding: 0 25px;
            overflow: visible;
        }
        
        .section.expanded .section-content {
            display: block;
            padding: 25px;
        }
        
        .section-content-inner {
            /* Content can grow freely */
        }
        
        /* Optional: Add smooth fade-in animation */
        .section.expanded .section-content {
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Expand/Collapse All Controls */
        .controls {
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .control-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        /* Rest of the styles */
        .figure {
            text-align: center;
            margin: 20px 0;
        }
        .figure img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            background: white;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #667eea;
            color: white;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        tr:hover {
            background-color: #e9ecef;
        }
        .text-content {
            color: #444;
            line-height: 1.8;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #667eea;
        }
        .katex-equation {
            text-align: center;
            margin: 20px 0;
            font-size: 1.2em;
        }
    </style>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
            onload="renderMathInElement(document.body);"></script>
    
</head>
<body>
    <div class="header">
        <h1>Post-Clustering Refinement ‚Äî Methodology Report</h1>
        <div class="metadata">
            <p><strong>Generated:</strong> 2026-02-19 06:39:19</p>
            <p><strong>Author:</strong> OCR Project</p>
            <p><strong>Items:</strong> 9</p>
        </div>
    </div>
    
    <div class="controls">
        <button class="control-btn" onclick="expandAll()">üìÇ Expand All</button>
        <button class="control-btn" onclick="collapseAll()">üìÅ Collapse All</button>
        <span style="margin-left: auto; color: #666; font-size: 0.9em;">
            Click section headers to toggle
        </span>
    </div>
    
    
    <div class="section collapsed" id="section-1">
        <div class="section-header" onclick="toggleSection(1)">
            <h2 class="section-title">1. Introduction</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Motivation & Pipeline Position</h3>
<div class="text-content">## Context<br>
<br>
After the Leiden community detection and Hausdorff-based hierarchical splitting, the pipeline produces a set of character clusters. Each cluster ideally groups all occurrences of a single character type. In practice, two systematic problems remain:<br>
<br>
<ol><li><strong>Mixed clusters</strong> ‚Äî A single cluster may contain two or more distinct characters that are visually similar (e.g. Â§ß and Â§™, or characters with similar stroke structure). CHAT OCR assigns different labels to these, revealing the mixture.</li><li><strong>Orphaned singletons (hapax)</strong> ‚Äî Characters that appear only once in the corpus end up in singleton clusters. Many of these actually belong to an existing multi-element cluster but were isolated because their HOG feature did not match strongly enough.</li></ol><br>
<br>
This report describes three post-clustering operations that exploit the CHAT OCR predictions (<code>char_chat</code>) to address these issues and produce a character glossary.<br>
<br>
## Pipeline Position<br>
<br>
These operations run <em>after</em> the existing clustering sweep and <em>before</em> any downstream analysis:<br>
<br>
<pre><code>Patches + HOG features
  ‚Üí A-contrario matching ‚Üí Leiden clustering ‚Üí Hausdorff splitting
  ‚Üí [NEW] CHAT-based cluster splitting          ‚Üê Operation 1
  ‚Üí [NEW] Hapax-to-cluster association           ‚Üê Operation 2
  ‚Üí [NEW] Glossary generation                   ‚Üê Operation 3
</code></pre></div>
            </div>
        </div>
    </div>
    
    <div class="section collapsed" id="section-2">
        <div class="section-header" onclick="toggleSection(2)">
            <h2 class="section-title">2. CHAT-Based Cluster Splitting</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Algorithm</h3>
<div class="text-content">## Problem Statement<br>
<br>
After Leiden + Hausdorff splitting, some clusters still contain patches labelled by CHAT as two or more distinct characters. For example, a cluster of 30 patches might have 18 labelled '‰∫∫' and 12 labelled 'ÂÖ•'. The Hausdorff splitting could not separate them because their binary shapes are metrically close.<br>
<br>
## Approach<br>
<br>
We use the CHAT OCR predictions as a <em>secondary signal</em> to sub-divide clusters that the shape-based pipeline could not resolve.<br>
<br>
### Algorithm<br>
<br>
For each cluster \(C_k\) with membership indices \(I_k\):<br>
<br>
<ol><li><strong>Collect CHAT labels</strong>: Let \(L_k = \{\ell_i : i \in I_k\}\) be the multiset of CHAT predictions, excluding unknown characters (\(\ell = \texttt{‚ñØ}\)).</li><li><strong>Count distinct labels</strong>: Let \(U_k = \text{unique}(L_k)\). If \(|U_k| \leq 1\), the cluster is <em>pure</em> w.r.t. CHAT ‚Äî skip it.</li><li><strong>Check dominance</strong>: Compute the label frequency distribution. If the most frequent label accounts for \(\geq p_{\text{pure}}\) (default 0.90) of known labels, treat the cluster as effectively pure ‚Äî the minority labels are likely CHAT errors. Skip.</li><li><strong>Split by CHAT label</strong>: Create one sub-cluster per CHAT label \(u \in U_k\):</li></ol><br>
$$S_{k,u} = \{i \in I_k : \ell_i = u\}$$<br>
<br>
<ol><li><strong>Assign unknowns</strong>: Patches with \(\ell_i = \texttt{‚ñØ}\) are not immediately placed. For each unknown patch \(i\):<br>- Compute the mean HOG dissimilarity \(\bar{d}(i, S_{k,u})\) to each sub-cluster \(S_{k,u}\)<br>- Assign \(i\) to \(\arg\min_u \bar{d}(i, S_{k,u})\)</li><li><strong>Reassign IDs</strong>: Replace the original cluster ID \(k\) with new contiguous IDs for each sub-cluster.</li></ol><br>
<br>
### Parameters<br>
<br>
<div class="table-container"><table><thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>purity_threshold</code></td><td>0.90</td><td>Minimum known-label purity to skip splitting</td></tr><tr><td><code>min_split_size</code></td><td>3</td><td>Minimum cluster size to consider for splitting</td></tr><tr><td><code>min_label_count</code></td><td>2</td><td>A CHAT label must appear ‚â• this many times to form its own sub-cluster (otherwise treated as noise)</td></tr></tbody></table></div><br>
</div>
<h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Robustness & Complexity</h3>
<div class="text-content">## Handling CHAT Errors<br>
<br>
CHAT OCR is not perfect. Several safeguards prevent erroneous splits:<br>
<br>
<ol><li><strong>Purity threshold</strong> (\(p_{\text{pure}} = 0.90\)): If 90% of known labels agree, a single outlier prediction is treated as OCR noise, not a genuine mixture. The cluster is left intact.</li><li><strong>Minimum label count</strong>: A CHAT label that appears only once in a cluster is almost certainly an error. Such singleton labels are folded into the dominant group rather than spawning their own sub-cluster.</li><li><strong>Unknown assignment</strong>: Patches with \(\ell = \texttt{‚ñØ}\) (CHAT could not recognise the character) are assigned by visual similarity, not by CHAT label. This prevents information loss.</li><li><strong>Confidence weighting</strong> (optional): When multiple CHAT labels are close in frequency, the mean confidence score \(\bar{c}_u = \frac{1}{|S_{k,u}|} \sum_{i \in S_{k,u}} c_i\) can serve as a tie-breaker ‚Äî groups with higher average CHAT confidence are more trustworthy.</li></ol><br>
<br>
## Complexity<br>
<br>
The splitting is \(O(K \cdot \max|I_k|)\) ‚Äî linear in the total number of patches. &nbsp;No pairwise distance computation is needed (the dissimilarity matrix from the matching step is reused only for unknown assignment). &nbsp;This is much cheaper than the Hausdorff splitting step.</div>
            </div>
        </div>
    </div>
    
    <div class="section collapsed" id="section-3">
        <div class="section-header" onclick="toggleSection(3)">
            <h2 class="section-title">3. Hapax-to-Cluster Association</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Algorithm</h3>
<div class="text-content">## Problem Statement<br>
<br>
A <em>hapax</em> (plural: <em>hapax legomena</em>) is a character that appears exactly once in the corpus. &nbsp;After clustering, these end up as singleton clusters ‚Äî clusters of size 1. &nbsp;Some of these are genuinely unique characters, but many are duplicates of existing multi-element clusters that the matching step missed.<br>
<br>
The goal is to merge hapax singletons into existing clusters where there is strong evidence (from CHAT) that they represent the same character, confirmed by visual similarity.<br>
<br>
## Algorithm<br>
<br>
<strong>Input</strong>: DataFrame with <code>membership</code>, <code>char_chat</code>, <code>conf_chat</code>, <code>histogram</code> columns. &nbsp;The dissimilarity matrix from the feature matching step.<br>
<br>
<strong>Step 1 ‚Äî Build cluster label index:</strong><br>
For each non-singleton cluster \(C_k\), compute its <em>dominant CHAT label</em>:<br>
$$\hat{\ell}_k = \arg\max_{\ell} \sum_{i \in C_k} \mathbb{1}[\ell_i = \ell]$$<br>
Build a dictionary: \(\text{label\_to\_clusters}[\ell] \to \{k : \hat{\ell}_k = \ell\}\).<br>
<br>
<strong>Step 2 ‚Äî For each hapax \(h\) with CHAT label \(\ell_h\):</strong><br>
<br>
<ol><li>If \(\ell_h = \texttt{‚ñØ}\), this hapax has no CHAT label ‚Äî it cannot be matched by OCR. &nbsp;<strong>Skip</strong> (it remains a singleton).</li><li>Look up candidate clusters: \(\mathcal{C}_h = \text{label\_to\_clusters}[\ell_h]\).</li><li>If \(|\mathcal{C}_h| = 0\), no existing cluster has this CHAT label. &nbsp;The hapax is genuinely unique. &nbsp;<strong>Skip</strong>.</li><li><strong>Visual verification</strong>: For each candidate cluster \(C_k\), compute the mean dissimilarity between the hapax and the cluster members:</li></ol><br>
$$\bar{d}(h, C_k) = \frac{1}{|C_k|} \sum_{i \in C_k} d(h, i)$$<br>
where \(d(h, i)\) is the precomputed HOG dissimilarity.<br>
<br>
<ol><li>Select the best candidate:</li></ol><br>
$$k^* = \arg\min_{k \in \mathcal{C}_h} \bar{d}(h, C_k)$$<br>
<br>
<ol><li><strong>Acceptance test</strong>: Accept the match if \(\bar{d}(h, C_{k^*}) < \tau_{\text{hapax}}\), where \(\tau_{\text{hapax}}\) is a dissimilarity threshold. &nbsp;A natural choice is the median intra-cluster dissimilarity of \(C_{k^*}\).</li><li>If accepted, set \(\text{membership}[h] = k^*\).</li></ol><br>
<br>
<strong>Step 3 ‚Äî Renumber</strong>: Renumber cluster IDs contiguously.</div>
<h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Design Decisions & Parameters</h3>
<div class="text-content">## Design Decisions<br>
<br>
<strong>Why require a CHAT label match?</strong> &nbsp;Without CHAT, we would need to search all \(K\) clusters for each hapax ‚Äî an \(O(K)\) scan. CHAT narrows the search to a handful of candidates (typically 0‚Äì2). More importantly, it prevents false merges between visually similar but semantically different characters.<br>
<br>
<strong>Why the visual verification step?</strong> &nbsp;CHAT can produce the same label for different characters (especially common radicals shared across characters). &nbsp;The dissimilarity check acts as a second opinion, preventing incorrect merges.<br>
<br>
<strong>What about hapax with \(\ell_h = \texttt{‚ñØ}\)?</strong> &nbsp;These patches could not be recognised by CHAT at all. &nbsp;Without a label to narrow the search, we have no reliable way to match them. They remain as singletons. &nbsp;A future improvement could use a k-NN fallback with a strict dissimilarity threshold.<br>
<br>
## Parameters<br>
<br>
<div class="table-container"><table><thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>hapax_max_dissimilarity</code></td><td><code>None</code> (use median intra-cluster)</td><td>Maximum mean dissimilarity to accept a hapax‚Äìcluster match</td></tr><tr><td><code>hapax_min_confidence</code></td><td>0.3</td><td>Minimum CHAT confidence for the hapax label to be trusted</td></tr></tbody></table></div><br>
</div>
            </div>
        </div>
    </div>
    
    <div class="section collapsed" id="section-4">
        <div class="section-header" onclick="toggleSection(4)">
            <h2 class="section-title">4. Glossary Generation</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Algorithm & Output</h3>
<div class="text-content">## Objective<br>
<br>
Produce a sorted inventory of all distinct characters found in the corpus, with occurrence counts and representative images. This is the primary deliverable for philological analysis.<br>
<br>
## Algorithm<br>
<br>
After CHAT-based splitting and hapax association, each cluster \(C_k\) represents a single character type (ideally).<br>
<br>
<strong>For each cluster \(C_k\):</strong><br>
<br>
<ol><li><strong>Canonical label</strong>: Take the dominant CHAT label among known patches:</li></ol><br>
$$\hat{\ell}_k = \arg\max_{\ell \neq \texttt{‚ñØ}} \sum_{i \in C_k} \mathbb{1}[\ell_i = \ell]$$<br>
If all patches are unknown, use \(\hat{\ell}_k = \texttt{‚ñØ}\).<br>
<br>
<ol><li><strong>Occurrence count</strong>: \(n_k = |C_k|\).</li><li><strong>Representative patch</strong>: The patch with the highest degree centrality in the similarity graph:</li></ol><br>
$$r_k = \arg\max_{i \in C_k} \text{degree\_centrality}(i)$$<br>
<br>
<ol><li><strong>Confidence score</strong>: Mean CHAT confidence over known patches:</li></ol><br>
$$\bar{c}_k = \frac{1}{|K_k|} \sum_{i \in K_k} c_i, \quad K_k = \{i \in C_k : \ell_i \neq \texttt{‚ñØ}\}$$<br>
<br>
<ol><li><strong>Purity</strong>: Fraction of known patches that agree with the dominant label:</li></ol><br>
$$p_k = \frac{\max_\ell |\{i \in K_k : \ell_i = \ell\}|}{|K_k|}$$<br>
<br>
## Output Format<br>
<br>
The glossary is a pandas DataFrame sorted by occurrence count (descending):<br>
<br>
<div class="table-container"><table><thead><tr><th>Column</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>character</code></td><td>str</td><td>Dominant CHAT label</td></tr><tr><td><code>count</code></td><td>int</td><td>Number of occurrences</td></tr><tr><td><code>cluster_id</code></td><td>int</td><td>Cluster ID after refinement</td></tr><tr><td><code>purity</code></td><td>float</td><td>Label agreement within cluster</td></tr><tr><td><code>mean_confidence</code></td><td>float</td><td>Mean CHAT confidence</td></tr><tr><td><code>representative_idx</code></td><td>int</td><td>DataFrame index of representative patch</td></tr><tr><td><code>pages</code></td><td>list</td><td>Pages on which this character appears</td></tr></tbody></table></div><br>
<br>
The glossary is also rendered as an HTML report section with thumbnail images of representative patches.</div>
            </div>
        </div>
    </div>
    
    <div class="section collapsed" id="section-5">
        <div class="section-header" onclick="toggleSection(5)">
            <h2 class="section-title">5. Operation Ordering & Interaction</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Ordering & Data Flow</h3>
<div class="text-content">## Execution Order<br>
<br>
The three operations are applied in a strict sequence:<br>
<br>
<ol><li><strong>CHAT-based splitting</strong> comes first, because it may increase the number of clusters. This creates new potential targets for hapax association.</li><li><strong>Hapax association</strong> comes second. It references the post-split cluster inventory and dominant labels. Running it after splitting ensures that previously-mixed clusters (which may have had ambiguous dominant labels) are now resolved.</li><li><strong>Glossary generation</strong> comes last, operating on the final, refined cluster assignments.</li></ol><br>
<br>
## Idempotency<br>
<br>
All three operations are deterministic given the same input. Re-running them produces identical results.<br>
<br>
## Data Flow<br>
<br>
<pre><code>Input: dataframe['membership']  (from Leiden + Hausdorff split)
       dataframe['char_chat']   (CHAT OCR predictions)
       dataframe['conf_chat']   (CHAT confidence scores)
       dataframe['histogram']   (HOG feature vectors)
       dissimilarities          (N√óN pairwise HOG dissimilarity matrix)

Step 1: chat_split(dataframe, purity_threshold=0.90)
        ‚Üí dataframe['membership'] updated (more clusters)
        ‚Üí dataframe['membership_pre_chat_split'] saved

Step 2: associate_hapax(dataframe, dissimilarities)
        ‚Üí dataframe['membership'] updated (fewer singletons)
        ‚Üí dataframe['membership_pre_hapax'] saved

Step 3: build_glossary(dataframe)
        ‚Üí glossary_df  (one row per character type)
</code></pre></div>
            </div>
        </div>
    </div>
    
    <div class="section collapsed" id="section-6">
        <div class="section-header" onclick="toggleSection(6)">
            <h2 class="section-title">6. Evaluation</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Evaluation Metrics</h3>
<div class="text-content">## Metrics<br>
<br>
Each operation is evaluated against the CHAT labels (as reference) using the same metrics already computed by the clustering sweep:<br>
<br>
<ul><li><strong>Adjusted Rand Index (ARI)</strong>: Measures agreement between predicted clusters and reference labels, adjusted for chance.</li><li><strong>Purity</strong>: Fraction of patches in a cluster that share the dominant label.</li><li><strong>Completeness</strong>: Fraction of a character's occurrences that are in the same cluster.</li></ul><br>
<br>
Additionally, we track operation-specific metrics:<br>
<br>
<div class="table-container"><table><thead><tr><th>Metric</th><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>Clusters split</td><td>Splitting</td><td>Number of clusters that were divided</td></tr><tr><td>Sub-clusters created</td><td>Splitting</td><td>Total new clusters from splitting</td></tr><tr><td>Mean post-split purity</td><td>Splitting</td><td>Average purity after splitting</td></tr><tr><td>Hapax matched</td><td>Association</td><td>Number of singletons merged</td></tr><tr><td>Hapax remaining</td><td>Association</td><td>Number of singletons still isolated</td></tr><tr><td>Match rate</td><td>Association</td><td>Fraction of hapax successfully merged</td></tr><tr><td>Glossary entries</td><td>Glossary</td><td>Number of distinct character types</td></tr><tr><td>Coverage</td><td>Glossary</td><td>Fraction of patches with a known character label</td></tr></tbody></table></div><br>
</div>
            </div>
        </div>
    </div>
    
    <div class="section collapsed" id="section-7">
        <div class="section-header" onclick="toggleSection(7)">
            <h2 class="section-title">7. Summary</h2>
            <div class="section-toggle">
                <span class="toggle-text">Click to expand</span>
                <div class="toggle-icon">‚ñ∂</div>
            </div>
        </div>
        <div class="section-content">
            <div class="section-content-inner">
                <h3 style="color: #555; margin: 25px 0 10px 0; padding-bottom: 6px; border-bottom: 1px solid #eee;">Summary</h3>
<div class="text-content">The three post-clustering operations form a lightweight refinement pass that leverages CHAT OCR as a secondary signal:<br>
<br>
<ol><li><strong>CHAT splitting</strong> resolves mixed clusters that shape-based splitting could not separate.</li><li><strong>Hapax association</strong> reduces singleton noise by merging orphaned characters into their correct cluster.</li><li><strong>Glossary generation</strong> produces the final character inventory.</li></ol><br>
<br>
All three operations are computationally cheap (no GPU, no new feature computation) and add at most a few seconds to the pipeline. The key insight is that CHAT provides a complementary signal to HOG features: while HOG captures shape similarity, CHAT captures semantic identity. Combining both gives a more accurate clustering.</div>
            </div>
        </div>
    </div>
    
    
    <script>
        // Toggle individual section
        function toggleSection(index) {
            const section = document.getElementById('section-' + index);
            const toggleText = section.querySelector('.toggle-text');
            
            section.classList.toggle('collapsed');
            section.classList.toggle('expanded');
            
            if (section.classList.contains('expanded')) {
                toggleText.textContent = 'Click to collapse';
            } else {
                toggleText.textContent = 'Click to expand';
            }
        }
        
        // Expand all sections
        function expandAll() {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('collapsed');
                section.classList.add('expanded');
                const toggleText = section.querySelector('.toggle-text');
                if (toggleText) toggleText.textContent = 'Click to collapse';
            });
        }
        
        // Collapse all sections
        function collapseAll() {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('expanded');
                section.classList.add('collapsed');
                const toggleText = section.querySelector('.toggle-text');
                if (toggleText) toggleText.textContent = 'Click to expand';
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                expandAll();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
                e.preventDefault();
                collapseAll();
            }
        });
    </script>
</body>
</html>